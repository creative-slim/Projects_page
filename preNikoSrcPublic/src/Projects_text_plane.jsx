/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/projects_text_plane.glb --transform 
Files: ./public/projects_text_plane.glb [56.53KB] > /Users/slim-cd/Documents/_Projects/__Creative Directors Website/website 2025/projects_plane/projects_text_plane-transformed.glb [7.45KB] (87%)
*/

import React, { useEffect } from "react";
import { useGLTF, useHelper } from "@react-three/drei";
import { Color, MeshBasicMaterial, ShaderMaterial } from "three";
import {
  useCursor,
  Outlines,
  AccumulativeShadows,
  RandomizedLight,
  OrbitControls,
  Bounds,
  Environment,
} from "@react-three/drei";
import { useThree, useFrame } from "@react-three/fiber";
import { useRef } from "react";
import { useControls } from "leva";

import * as THREE from "three";

// import fragment from "./shaders/fragment_updated.glsl";
// import vertex from "./shaders/vertex_updated.glsl";
// import uniforms from "./shaders/uniforms_updated.json";

export function TextModel(props) {
  const textObj = useRef();
  const lightRef = useRef();
  const planeText = useRef();
  const planeObj = useRef();
  const { scene, size, camera } = useThree();

  const glowBlue = new MeshBasicMaterial({
    // color: new Color(1.5, 1.4, 1.3), // Exaggerated #F4E7D7
    color: new Color("#F4E7D7"), // Exaggerated #F4E7D7
    toneMapped: false,
  });

  const { nodes, materials } = useGLTF(
    "/models/projects_text_plane-transformed.glb"
  );

  // Flattened Leva controls
  const {
    intensity,
    color,
    yMin,
    yMax,
    zMin,
    zMax,
    planeColor,
    metalness,
    roughness,
    reflectivity,
  } = useControls({
    intensity: { value: 15, min: 0, max: 500, step: 1 },
    color: "#ffffff",
    yMin: { value: 7, min: -20, max: 20, step: 0.1 },
    yMax: { value: -7, min: -20, max: 20, step: 0.1 },
    zMin: { value: 14, min: -20, max: 20, step: 0.1 },
    zMax: { value: -14, min: -20, max: 20, step: 0.1 },
    planeColor: "#F4E7D7", // Default color for planeObj
    metalness: { value: 0.16, min: 0, max: 1, step: 0.01 },
    roughness: { value: 0.5, min: 0, max: 1, step: 0.01 },
    reflectivity: { value: 0.5, min: 0, max: 1, step: 0.01 },
  });

  useEffect(() => {
    const handleMouseMove = (event) => {
      const normalizedY = (event.clientY / size.height) * 2 - 1; // Normalize mouse Y to range [-1, 1]
      const normalizedZ = (event.clientX / size.width) * 2 - 1; // Normalize mouse X to range [-1, 1]
      if (lightRef.current) {
        lightRef.current.position.y = THREE.MathUtils.lerp(
          yMin,
          yMax,
          (normalizedY + 1) / 2
        ); // Map to range [yMin, yMax] for Y-axis
        lightRef.current.position.z = THREE.MathUtils.lerp(
          zMin,
          zMax,
          (normalizedZ + 1) / 2
        ); // Map to range [zMin, zMax] for Z-axis
      }
      // camera.position.x = THREE.MathUtils.lerp(
      //   0.5,
      //   -0.5,
      //   (normalizedZ + 1) / 2
      // ); // Move camera left and right
    };

    window.addEventListener("mousemove", handleMouseMove);
    return () => window.removeEventListener("mousemove", handleMouseMove);
  }, [size, camera, yMin, yMax, zMin, zMax]);

  useFrame(() => {
    if (lightRef.current && textObj.current) {
      lightRef.current.target = textObj.current; // Ensure the light targets the text object
    }
    if (planeObj.current && planeObj.current.material) {
      planeObj.current.material.color = new THREE.Color(planeColor); // Update planeObj color dynamically
      planeObj.current.material.metalness = metalness; // Update metalness dynamically
      planeObj.current.material.roughness = roughness; // Update roughness dynamically
      planeObj.current.material.reflectivity = reflectivity; // Update reflectivity dynamically
    }
  });

  return (
    <group castShadow receiveShadow {...props} dispose={null}>
      <pointLight
        ref={lightRef}
        position={[7, 2, 0]} // Initial position
        intensity={intensity} // Controlled by Leva
        color={color} // Controlled by Leva
        penumbra={0.3}
        decay={2}
        distance={100}
        castShadow
        shadow-mapSize-width={512} // Increase shadow map resolution
        shadow-mapSize-height={512} // Increase shadow map resolution
      />

      <group ref={planeText}>
        <mesh
          ref={textObj}
          castShadow
          receiveShadow
          geometry={nodes.Text.geometry}
          position={[3.118, 1.232, 5.212]}
          rotation={[Math.PI / 2, 0, -Math.PI / 2]}
          scale={2.444}
        >
          <meshStandardMaterial
            color={new Color("#F4E7D7")} // Exaggerated #F4E7D7
            emissive={new Color("#F4E7D7")} // Emissive color
            emissiveIntensity={0.5} // Emissive intensity
            toneMapped={false}
          />
        </mesh>
        <mesh
          ref={planeObj}
          geometry={nodes.Plane.geometry}
          position={[3, 0, 0]}
          receiveShadow
          castShadow
        >
          <meshStandardMaterial
            color={planeColor} // Controlled by Leva
            metalness={0.16} // Controlled by Leva
            roughness={roughness} // Controlled by Leva
            emissive={new Color("#F4E7D7")} // Emissive color
            emissiveIntensity={0.5} // Emissive intensity
            reflectivity={reflectivity} // Controlled by Leva
            opacity={1}
          />
        </mesh>
      </group>
    </group>
  );
}

useGLTF.preload("/models/projects_text_plane-transformed.glb");
